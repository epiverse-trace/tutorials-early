---
title: Agréger et visualiser
teaching: 20
exercises: 10
---

:::::::::::::::::::::::::::::::::::::: questions

- Comment agréger et résumer les données relatives aux cas ?
- Comment visualiser les données agrégées ?
- Quelle est la répartition des cas dans le temps, le lieu, le sexe, l'âge ?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Simuler des données synthétiques sur les épidémies
- Convertir les données des listes individuelles en incidence dans le temps
- Créer des courbes épidémiques à partir de données d'incidence
  ::::::::::::::::::::::::::::::::::::::::::::::::

## Introduction

Dans un pipeline analytique, l'analyse exploratoire des données (AED) est une étape importante avant la modélisation formelle. L'AED aide à
de déterminer les relations entre les variables et de résumer leurs principales caractéristiques, souvent au moyen de la visualisation des données.

Cet épisode se concentre sur l'analyse des données d'épidémies à l'aide de packages R.
L'un des aspects clés de l'analyse des données épidémiques est la notion de "personne, lieu et temps". Il est utile d'identifier comment les événements observés - tels que les cas confirmés, les hospitalisations, les décès et les guérisons - évoluent dans le temps et comment ils varient en fonction des différents lieux et facteurs démographiques, notamment le sexe, l'âge, etc.

Commençons par charger le paquet `{incidence2}` afin d'agréger les données de la liste de diffusion en fonction de caractéristiques spécifiques et de visualiser les courbes épidémiques (épicurves) qui en résultent et qui représentent le nombre de nouveaux événements (c'est-à-dire l'incidence) au fil du temps.
Nous utiliserons `{simulist}` pour simuler des données d'épidémies à analyser, et `{tracetheme}` pour le formatage des figures.
Nous utiliserons le tuyau `%>%` pour connecter certaines de leurs fonctions, y compris celles des paquets `{dplyr}` et
`{ggplot2}` Nous allons donc également faire appel au paquet tidyverse :

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Load packages
library(incidence2) # For aggregating and visualising
library(simulist) # For simulating linelist data
library(tracetheme) # For formatting figures
library(tidyverse) # For {dplyr} and {ggplot2} functions and the pipe %>%
```

::::::::::::::::::: checklist

### Le double point-virgule

Le double point-virgule `::` dans R vous permet d'appeler une fonction spécifique d'un paquetage sans charger l'ensemble du paquetage dans l'environnement actuel.

Par exemple, vous pouvez appeler une fonction spécifique d'un package sans charger le package entier dans l'environnement actuel, `dplyr::filter(data, condition)` utilise `filter()` à partir de l'outil `{dplyr}` paquet.
Cela nous permet de nous souvenir des fonctions du paquet et d'éviter les conflits d'espace de noms.

:::::::::::::::::::

## Données synthétiques sur les épidémies

Pour illustrer le processus d'analyse des données sur les épidémies, nous allons générer une liste de lignes
pour une épidémie hypothétique à l'aide de l'outil `{simulist}` paquet. `{simulist}` génère des données de simulation pour une épidémie selon une configuration donnée.
Sa configuration minimale permet de générer une liste d'adresses, comme le montre le morceau de code ci-dessous :

```{r}
# Simulate linelist data for an outbreak with size between 1000 and 1500
set.seed(1) # Set seed for reproducibility
sim_data <- simulist::sim_linelist(outbreak_size = c(1000, 1500)) %>%
  dplyr::as_tibble() # for a simple data frame output

# Display the simulated dataset
sim_data
```

Cet ensemble de données de liste contient des entrées sur les événements simulés au niveau individuel pendant l'épidémie.

::::::::::::::::::: spoiler

## Ressources supplémentaires sur les données relatives aux foyers

Ce qui précède est la configuration par défaut de `{simulist}` Elle comprend donc un certain nombre d'hypothèses sur la transmissibilité et la gravité de l'agent pathogène. Si vous souhaitez en savoir plus sur `sim_linelist()` et d'autres fonctionnalités
consultez le site [site de documentation](https://epiverse-trace.github.io/simulist/).

Vous pouvez également trouver des ensembles de données concernant des urgences réelles du passé sur le site [`{outbreaks}` paquet R](https://www.reconverse.org/outbreaks/).

:::::::::::::::::::

## Agrégation

Souvent, nous voulons analyser et visualiser le nombre d'événements qui se produisent un jour ou une semaine donnés, plutôt que de nous concentrer sur des cas individuels. Pour ce faire, il est nécessaire de regrouper les données de la liste de diffusion
 en données d'incidence. Les données [incidence2] (([https://www.reconverse.org/incidence2/articles/incidence2.html){.externe
](https://www.reconverse.org/incidence2/articles/incidence2.html\){.external) target="\_blank"})
offre une fonction utile appelée `incidence2::incidence()` qui permet de regrouper les données relatives à un cas, généralement en fonction d'événements datés.
et/ou d'autres caractéristiques. Le morceau de code fourni ci-dessous démontre la création d'une fonction `<incidence2>` à partir de la classe
Ebola simulé `linelist` sur la base de la date d'apparition.

```{r}
# Create an incidence object by aggregating case data based on the date of onset
daily_incidence <- incidence2::incidence(
  sim_data,
  date_index = "date_onset",
  interval = "day" # Aggregate by daily intervals
)

# View the incidence data
daily_incidence
```

Avec les `{incidence2}` vous pouvez spécifier l'intervalle souhaité (par exemple, le jour, la semaine) et classer les cas selon une ou plusieurs catégories.
plusieurs facteurs. Vous trouverez ci-dessous un extrait de code montrant des cas hebdomadaires regroupés selon la date d'apparition, le sexe et le type de cas.

```{r}
# Group incidence data by week, accounting for sex and case type
weekly_incidence <- incidence2::incidence(
  sim_data,
  date_index = "date_onset",
  interval = "week", # Aggregate by weekly intervals
  groups = c("sex", "case_type") # Group by sex and case type
)

# View the incidence data
weekly_incidence
```

::::::::::::::::::::::::::::::::::::: callout

## Dates d'achèvement

Lorsque les affaires sont regroupées en fonction de différents facteurs, il est possible que les événements impliquant ces groupes aient des dates différentes dans la base de données de l
qui en résultent `incidence2` qui en résulte. L'objet `incidence2` fournit une fonction appelée `complete_dates()` pour s'assurer qu'un
a la même plage de dates pour chaque groupe. Par défaut, les chiffres manquants pour un groupe particulier seront complétés par 0 pour cette date.

Cette fonctionnalité est également disponible en tant qu'argument dans `incidence2::incidence()` ajouter `complete_dates = TRUE`.

```{r}
# Create an incidence object grouped by sex, aggregating daily
daily_incidence_2 <- incidence2::incidence(
  sim_data,
  date_index = "date_onset",
  groups = "sex",
  interval = "day", # Aggregate by daily intervals
  complete_dates = TRUE # Complete missing dates in the incidence object
)
```

```{r, echo=FALSE, eval=FALSE}
daily_incidence_2_complete <- incidence2::complete_dates(
  x = daily_incidence_2,
  expand = TRUE, # Expand to fill in missing dates
  fill = 0L,     # Fill missing values with 0
  by = 1L,       # Fill by daily intervals
  allow_POSIXct = FALSE # Ensure that dates are not in POSIXct format
)
```

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: challenge

## Défi 1 : Pouvez-vous le faire ?

- **Tâche** Tâche : Agrégat `sim_data` la liste d'attente en fonction de la date d'admission et de l'issue du cas en **bihebdomadaire**
  et enregistrez les résultats dans un objet appelé `biweekly_incidence`.

::::::::::::::::::::::::::::::::::::::::::::::::

## Visualisation

La `incidence2` peut être visualisé à l'aide de la fonction `plot()` du paquetage R de base.
Le graphique qui en résulte est appelé courbe épidémique, ou épi-courbe. Le code suivant
suivants génèrent des épi-courbes pour le modèle `daily_incidence` et `weekly_incidence` mentionnés ci-dessus.

```{r}
# Plot daily incidence data
base::plot(daily_incidence) +
  ggplot2::labs(
    x = "Time (in days)", # x-axis label
    y = "Dialy cases" # y-axis label
  ) +
  tracetheme::theme_trace() # Apply the custom trace theme
```

```{r}
# Plot weekly incidence data
base::plot(weekly_incidence) +
  ggplot2::labs(
    x = "Time (in weeks)", # x-axis label
    y = "weekly cases" # y-axis label
  ) +
  tracetheme::theme_trace() # Apply the custom trace theme
```

:::::::::::::::::::::::: callout

#### Esthétique simple

Nous vous invitons à parcourir le `{incidence2}` paquet ["Vignette "Pour commencer](https://www.reconverse.org/incidence2/articles/incidence2.html). Découvrez comment vous pouvez utiliser des arguments dans `plot()` pour donner de l'esthétique à vos objets de la classe incidence2.

```{r}
base::plot(weekly_incidence, fill = "sex")
```

Certains d'entre eux incluent `show_cases = TRUE`, `angle = 45` et `n_breaks = 5`. N'hésitez pas à les essayer.

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: challenge

## Défi 2 : Pouvez-vous le faire ?

- **Tâche** Visualiser `biweekly_incidence` objet.

::::::::::::::::::::::::::::::::::::::::::::::::

## Courbe des cas cumulés

Le nombre cumulé de cas peut être calculé à l'aide de la courbe des cas cumulés. `cumulate()` à partir d'un `incidence2` et visualisé, comme dans l'exemple ci-dessous.

```{r}
# Calculate cumulative incidence
cum_df <- incidence2::cumulate(daily_incidence)

# Plot cumulative incidence data using ggplot2
base::plot(cum_df) +
  ggplot2::labs(
    x = "Time (in days)", # x-axis label
    y = "weekly cases" # y-axis label
  ) +
  tracetheme::theme_trace() # Apply the custom trace theme
```

Notez que cette fonction préserve le regroupement, c'est-à-dire que si la fonction `incidence2` contient des groupes, elle accumulera les cas en conséquence.

::::::::::::::::::::::::::::::::::::: challenge

## Défi 3 : Pouvez-vous le faire ?

- **Tâche** Visuliser les cas cumulés de `biweekly_incidence` l'objet.

::::::::::::::::::::::::::::::::::::::::::::::::

## Estimation des pics

Vous pouvez estimer le pic - le moment où le nombre de cas enregistrés est le plus élevé - à l'aide de la fonction `estimate_peak()` de la fonction {incidence2} paquet.
Cette fonction utilise une méthode de bootstrap pour déterminer l'heure de pointe (c'est-à-dire en rééchantillonnant les dates avec remplacement, ce qui donne une distribution des heures de pointe estimées).

```{r}
# Estimate the peak of the daily incidence data
peak <- incidence2::estimate_peak(
  daily_incidence,
  n = 100,         # Number of simulations for the peak estimation
  alpha = 0.05,    # Significance level for the confidence interval
  first_only = TRUE, # Return only the first peak found
  progress = FALSE  # Disable progress messages
)

# Display the estimated peak
print(peak)
```

Cet exemple montre comment estimer l'heure de pointe à l'aide de la fonction `estimate_peak()` à $95%$
et en utilisant 100 échantillons bootstrap.

::::::::::::::::::::::::::::::::::::: challenge

## Défi 4 : Pouvez-vous le faire ?

- **Tâche** Estimation de l'heure de pointe à partir de `biweekly_incidence` l'objet.

::::::::::::::::::::::::::::::::::::::::::::::::

## Visualisation avec ggplot2

`{incidence2}` permet d'obtenir des tracés de base pour les épicurves, mais un travail supplémentaire est nécessaire pour créer des graphiques bien annotés. Cependant, l'utilisation de l'outil `{ggplot2}` vous pouvez générer des graphes plus sophistiqués et des épicurves avec plus de flexibilité dans l'annotation.
`{ggplot2}` est un logiciel complet qui offre de nombreuses fonctionnalités. Cependant, nous nous concentrerons sur trois éléments clés pour la production d'épicurves : les tracés d'histogrammes, la mise à l'échelle des axes de date et de leurs étiquettes, et l'annotation générale du thème du tracé.
L'exemple ci-dessous montre comment configurer ces trois éléments pour un tracé d'histogramme simple. `{incidence2}` simple.

```{r}
# Define date breaks for the x-axis
breaks <- seq.Date(
  from = min(as.Date(daily_incidence$date_index, na.rm = TRUE)),
  to = max(as.Date(daily_incidence$date_index, na.rm = TRUE)),
  by = 20 # every 20 days
)

# Create the plot
ggplot2::ggplot(data = daily_incidence) +
  geom_histogram(
    mapping = aes(
      x = as.Date(date_index),
      y = count
    ),
    stat = "identity",
    color = "blue", # bar border color
    fill = "lightblue", # bar fill color
    width = 1 # bar width
  ) +
  theme_minimal() + # apply a minimal theme for clean visuals
  theme(
    plot.title = element_text(face = "bold",
                              hjust = 0.5), # center and bold title
    plot.subtitle = element_text(hjust = 0.5), # center subtitle
    plot.caption = element_text(face = "italic",
                                hjust = 0), # italicized caption
    axis.title = element_text(face = "bold"), # bold axis titles
    axis.text.x = element_text(angle = 45, vjust = 0.5) # rotated x-axis text
  ) +
  labs(
    x = "Date", # x-axis label
    y = "Number of cases", # y-axis label
    title = "Daily Outbreak Cases", # plot title
    subtitle = "Epidemiological Data for the Outbreak", # plot subtitle
    caption = "Data Source: Simulated Data" # plot caption
  ) +
  scale_x_date(
    breaks = breaks, # set custom breaks on the x-axis
    labels = scales::label_date_short() # shortened date labels
  )
```

Utilisez l'outil `group` dans la fonction de mappage pour visualiser une courbe épique avec différents groupes. S'il y a plus d'un facteur de regroupement, utilisez l'option `facet_wrap()` comme le montre l'exemple ci-dessous :

```{r}
# Plot daily incidence by sex with facets
ggplot2::ggplot(data = daily_incidence_2) +
  geom_histogram(
    mapping = aes(
      x = as.Date(date_index),
      y = count,
      group = sex,
      fill = sex
    ),
    stat = "identity"
  ) +
  theme_minimal() + # apply minimal theme
  theme(
    plot.title = element_text(face = "bold",
                              hjust = 0.5), # bold and center the title
    plot.subtitle = element_text(hjust = 0.5), # center the subtitle
    plot.caption = element_text(face = "italic", hjust = 0), # italic caption
    axis.title = element_text(face = "bold"), # bold axis labels
    axis.text.x = element_text(angle = 45,
                               vjust = 0.5) # rotate x-axis text for readability
  ) +
  labs(
    x = "Date", # x-axis label
    y = "Number of cases", # y-axis label
    title = "Daily Outbreak Cases by Sex", # plot title
    subtitle = "Incidence of Cases Grouped by Sex", # plot subtitle
    caption = "Data Source: Simulated Data" # caption for additional context
  ) +
  facet_wrap(~sex) + # create separate panels by sex
  scale_x_date(
    breaks = breaks, # set custom date breaks
    labels = scales::label_date_short() # short date format for x-axis labels
  ) +
  scale_fill_manual(values = c("lightblue",
                               "lightpink")) # custom fill colors for sex
```

::::::::::::::::::::::::::::::::::::: challenge

## Défi 5 : Pouvez-vous le faire ?

- **Tâche** Produire une figure annotée pour biweekly\_incidence à l'aide de `{ggplot2}` paquet.

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: keypoints

- Utiliser `{simulist}` pour générer des données synthétiques sur les foyers
- Utiliser `{incidence2}` pour agréger les données sur les cas en fonction d'une date d'événement et produire des courbes épidémiques.
- Utilisez `{ggplot2}` pour produire des courbes épidémiques mieux annotées.

::::::::::::::::::::::::::::::::::::::::::::::::


